/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * Licensed under the Oculus SDK License Agreement (the "License");
 * you may not use the Oculus SDK except in compliance with the License,
 * which is provided at the time of installation or download, or which
 * otherwise accompanies this software in either electronic or hard copy form.
 *
 * You may obtain a copy of the License at
 *
 * https://developer.oculus.com/licenses/oculussdk/
 *
 * Unless required by applicable law or agreed to in writing, the Oculus SDK
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using Oculus.Interaction.Throw;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Pool;

namespace Oculus.Interaction
{
    /// <summary>
    /// Moves the object it's attached to when an Interactor selects that object.
    /// </summary>
    public class Grabbable : PointableElement, IGrabbable, ITimeConsumer
    {
        /// <summary>
        /// A One Grab...Transformer component, which should be attached to the grabbable object. Defaults to One Grab Free Transformer.
        /// If you set the Two Grab Transformer property and still want to use one hand for grabs, you must set this property as well.
        /// </summary>
        [Tooltip("A One Grab...Transformer component, which should be attached to the grabbable object. Defaults to One Grab Free Transformer. If you set the Two Grab Transformer property and still want to use one hand for grabs, you must set this property as well.")]
        [SerializeField, Interface(typeof(ITransformer))]
        [Optional(OptionalAttribute.Flag.AutoGenerated)]
        private UnityEngine.Object _oneGrabTransformer = null;

        /// <summary>
        /// A Two Grab...Transformer component, which should be attached to the grabbable object.
        /// If you set this property but also want to use one hand for grabs, you must set the One Grab Transformer property.
        /// </summary>
        [Tooltip("A Two Grab...Transformer component, which should be attached to the grabbable object. If you set this property but also want to use one hand for grabs, you must set the One Grab Transformer property.")]
        [SerializeField, Interface(typeof(ITransformer))]
        [Optional(OptionalAttribute.Flag.AutoGenerated)]
        private UnityEngine.Object _twoGrabTransformer = null;

        /// <summary>
        /// Takes a target object to transform instead of transforming the object that has the Grabbable component.
        /// The object with the Grabbable component acts as a controller that projects its transforms onto the target object.
        /// </summary>
        [Tooltip("The target transform of the Grabbable. If unassigned, " +
            "the transform of this GameObject will be used.")]
        [SerializeField]
        [Optional(OptionalAttribute.Flag.AutoGenerated)]
        private Transform _targetTransform;

        /// <summary>
        /// The maximum number of grab points. Can be either -1 (unlimited), 1, or 2.
        /// </summary>
        [Tooltip("The maximum number of grab points. Can be either -1 (unlimited), 1, or 2.")]
        [SerializeField, Min(-1)]
        private int _maxGrabPoints = -1;

        [Header("Physics")]
        [SerializeField, Optional(OptionalAttribute.Flag.DontHide)]
        [Tooltip("Use this rigidbody to control its physics properties while grabbing.")]
        private Rigidbody _rigidbody;
        [SerializeField]
        [Tooltip("Locks the referenced rigidbody to a kinematic while selected.")]
        private bool _kinematicWhileSelected = true;
        [SerializeField]
        [Tooltip("Applies throwing velocities to the rigidbody when fully released.")]
        private bool _throwWhenUnselected = true;

        public int MaxGrabPoints
        {
            get
            {
                return _maxGrabPoints;
            }
            set
            {
                _maxGrabPoints = value;
            }
        }

        public Transform Transform => _targetTransform;
        public List<Pose> GrabPoints => _selectingPoints;

        private Func<float> _timeProvider = () => Time.time;
        public void SetTimeProvider(Func<float> timeProvider)
        {
            _timeProvider = timeProvider;
            if (_throw != null)
            {
                _throw.SetTimeProvider(timeProvider);
            }
        }

        private ITransformer _activeTransformer = null;
        private ITransformer OneGrabTransformer;
        private ITransformer TwoGrabTransformer;

        private ThrowWhenUnselected _throw;

        private bool _isKinematicLocked = false;

        #region Editor
        protected virtual void Reset()
        {
            _rigidbody = this.GetComponent<Rigidbody>();
        }
        #endregion

        protected override void Awake()
        {
            base.Awake();
            OneGrabTransformer = _oneGrabTransformer as ITransformer;
            TwoGrabTransformer = _twoGrabTransformer as ITransformer;
        }

        protected override void Start()
        {
            this.BeginStart(ref _started, () => base.Start());

            if (_targetTransform == null)
            {
                _targetTransform = transform;
            }

            if (_oneGrabTransformer != null)
            {
                this.AssertField(OneGrabTransformer, nameof(OneGrabTransformer));
                OneGrabTransformer.Initialize(this);
            }

            if (_twoGrabTransformer != null)
            {
                this.AssertField(TwoGrabTransformer, nameof(TwoGrabTransformer));
                TwoGrabTransformer.Initialize(this);
            }

            // Create missing defaults
            if (OneGrabTransformer == null && TwoGrabTransformer == null)
            {
                ITransformer transformer = GenerateTransformer();
                transformer.Initialize(this);
            }

            if (_rigidbody != null && _throwWhenUnselected)
            {
                _throw = new ThrowWhenUnselected(_rigidbody, this);
                _throw.SetTimeProvider(this._timeProvider);
            }

            this.EndStart(ref _started);
        }

        protected override void OnDisable()
        {
            if (_started)
            {
                EndTransform();
            }

            base.OnDisable();
        }

        protected virtual void OnDestroy()
        {
            if (_throw != null)
            {
                _throw.Dispose();
                _throw = null;
            }
        }

        private ITransformer GenerateTransformer()
        {
            ITransformer transformer = gameObject.AddComponent<GrabFreeTransformer>();
            this.InjectOptionalOneGrabTransformer(transformer);
            this.InjectOptionalTwoGrabTransformer(transformer);
            return transformer;
        }

        public override void ProcessPointerEvent(PointerEvent evt)
        {
            switch (evt.Type)
            {
                case PointerEventType.Select:
                    EndTransform();
                    break;
                case PointerEventType.Unselect:
                    ForceMove(evt);
                    EndTransform();
                    break;
                case PointerEventType.Cancel:
                    EndTransform();
                    break;
            }

            base.ProcessPointerEvent(evt);

            switch (evt.Type)
            {
                case PointerEventType.Select:
                    BeginTransform();
                    break;
                case PointerEventType.Unselect:
                    BeginTransform();
                    break;
                case PointerEventType.Move:
                    UpdateTransform();
                    break;
            }
        }

        protected override void PointableElementUpdated(PointerEvent evt)
        {
            UpdateKinematicLock(SelectingPointsCount > 0);

            base.PointableElementUpdated(evt);
        }

        private void UpdateKinematicLock(bool isGrabbing)
        {
            if (_rigidbody == null
                || !_kinematicWhileSelected)
            {
                return;
            }

            if (!_isKinematicLocked && isGrabbing)
            {
                _isKinematicLocked = true;
                _rigidbody.LockKinematic();
            }
            else if (_isKinematicLocked && !isGrabbing)
            {
                _isKinematicLocked = false;
                _rigidbody.UnlockKinematic();
            }
        }

        private void ForceMove(PointerEvent releaseEvent)
        {
            PointerEvent moveEvent = new PointerEvent(releaseEvent.Identifier,
                PointerEventType.Move, releaseEvent.Pose, releaseEvent.Data);
            ProcessPointerEvent(moveEvent);
        }

        // Whenever we change the number of grab points, we save the
        // current transform data
        private void BeginTransform()
        {
            // End the transform on any existing transformer before we
            // begin the new one
            EndTransform();

            int useGrabPoints = _selectingPoints.Count;
            if (_maxGrabPoints != -1)
            {
                useGrabPoints = Mathf.Min(useGrabPoints, _maxGrabPoints);
            }

            switch (useGrabPoints)
            {
                case 1:
                    _activeTransformer = OneGrabTransformer;
                    break;
                case 2:
                    _activeTransformer = TwoGrabTransformer;
                    break;
                default:
                    _activeTransformer = null;
                    break;
            }

            if (_activeTransformer == null)
            {
                return;
            }

            _activeTransformer.BeginTransform();
        }

        private void UpdateTransform()
        {
            if (_activeTransformer == null)
            {
                return;
            }

            _activeTransformer.UpdateTransform();
        }

        private void EndTransform()
        {
            if (_activeTransformer == null)
            {
                return;
            }
            _activeTransformer.EndTransform();
            _activeTransformer = null;
        }

        #region Inject

        public void InjectOptionalOneGrabTransformer(ITransformer transformer)
        {
            _oneGrabTransformer = transformer as UnityEngine.Object;
            OneGrabTransformer = transformer;
        }

        public void InjectOptionalTwoGrabTransformer(ITransformer transformer)
        {
            _twoGrabTransformer = transformer as UnityEngine.Object;
            TwoGrabTransformer = transformer;
        }

        public void InjectOptionalTargetTransform(Transform targetTransform)
        {
            _targetTransform = targetTransform;
        }

        public void InjectOptionalRigidbody(Rigidbody rigidbody)
        {
            _rigidbody = rigidbody;
        }

        public void InjectOptionalThrowWhenUnselected(bool throwWehenUnselected)
        {
            _throwWhenUnselected = throwWehenUnselected;
        }

        public void InjectOptionalKinematicWhileSelected(bool kinematicWhileSelected)
        {
            _kinematicWhileSelected = kinematicWhileSelected;
        }

        #endregion

        /// <summary>
        /// Tracks the movement of a rigidbody while it is selected by an IPointable
        /// and applies a throw velocity when it becomes fully unselected.
        /// </summary>
        private class ThrowWhenUnselected : ITimeConsumer, IDisposable
        {
            private Rigidbody _rigidbody;
            private IPointable _pointable;

            private Func<float> _timeProvider = () => Time.time;
            public void SetTimeProvider(Func<float> timeProvider)
            {
                _timeProvider = timeProvider;
            }

            private static IObjectPool<RANSACVelocity> _ransacVelocityPool = new ObjectPool<RANSACVelocity>(
                createFunc: () => new RANSACVelocity(8, 2, 2),
                collectionCheck: false,
                defaultCapacity: 2);

            private RANSACVelocity _ransacVelocity = null;

            private Pose _lastPose = Pose.identity;
            private float _lastTime = 0f;
            private bool _isHighConfidence = true;

            private int _selectorsCount = 0;

            /// <summary>
            /// Creates a new instance that listens to the provided IPointable events.
            /// Note that this instance must be disposed via .Dispose() to release the event listener.
            /// </summary>
            /// <param name="rigidbody">The rigidbody to track velocity from and throw.</param>
            /// <param name="pointable">The IPointable indicating when the rigidbody is selected and unselected.</param>
            public ThrowWhenUnselected(Rigidbody rigidbody, IPointable pointable)
            {
                _rigidbody = rigidbody;
                _pointable = pointable;

                _pointable.WhenPointerEventRaised += HandlePointerEventRaised;
            }

            /// <summary>
            /// Unregisters the instance from the IPointable events
            /// </summary>
            public void Dispose()
            {
                _pointable.WhenPointerEventRaised -= HandlePointerEventRaised;
            }

            private void AddSelection()
            {
                if (_selectorsCount++ == 0)
                {
                    Initialize();
                }
            }

            private void RemoveSelection(bool canThrow)
            {
                if (--_selectorsCount == 0)
                {
                    if (canThrow)
                    {
                        Process(true);
                        LoadThrowVelocities();
                    }
                    Teardown();
                }
                _selectorsCount = Mathf.Max(0, _selectorsCount);
            }

            private void HandlePointerEventRaised(PointerEvent evt)
            {
                switch (evt.Type)
                {
                    case PointerEventType.Select:
                        AddSelection();
                        break;
                    case PointerEventType.Move:
                        if (_selectorsCount > 0)
                        {
                            Process(false);
                            MarkFrameConfidence(evt.Identifier);
                        }
                        break;
                    case PointerEventType.Cancel:
                        RemoveSelection(false);
                        break;
                    case PointerEventType.Unselect:
                        MarkFrameConfidence(evt.Identifier);
                        RemoveSelection(true);
                        break;
                }
            }

            private void Initialize()
            {
                Pose rootPose = _rigidbody.transform.GetPose();
                float time = _timeProvider.Invoke();

                _ransacVelocity = _ransacVelocityPool.Get();
                _ransacVelocity.Initialize(rootPose, time);
            }

            private void Teardown()
            {
                _ransacVelocityPool.Release(_ransacVelocity);
                _ransacVelocity = null;
            }

            private void MarkFrameConfidence(int emitterKey)
            {
                if (!_isHighConfidence)
                {
                    return;
                }

                if (HandTrackingConfidenceProvider.TryGetTrackingConfidence(emitterKey, out bool isHighConfidence))
                {
                    if (!isHighConfidence)
                    {
                        _isHighConfidence = false;
                    }
                }
            }

            private void Process(bool forceSubmit)
            {
                float time = _timeProvider.Invoke();
                Pose pose = _rigidbody.transform.GetPose();

                if (time > _lastTime || forceSubmit)
                {
                    _isHighConfidence &= pose.position != _lastPose.position;
                    _ransacVelocity.Process(pose,
                        forceSubmit ? time : _lastTime,
                        _isHighConfidence);
                    _isHighConfidence = true;
                }

                _lastTime = time;
                _lastPose = pose;
            }

            private void LoadThrowVelocities()
            {
                _ransacVelocity.GetVelocities(out Vector3 velocity, out Vector3 torque);
                _rigidbody.velocity = velocity;
                _rigidbody.angularVelocity = torque;
            }

        }
    }
}
